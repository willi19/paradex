import numpy as np
import pickle
import os
import open3d as o3d
from curobo.wrap.reacher.motion_gen import MotionGen, MotionGenConfig, MotionGenPlanConfig, PoseCostMetric
from curobo.geom.types import WorldConfig
from curobo.types.base import TensorDeviceType
import trimesh
from scipy.spatial.transform import Rotation as R
# Pick Target 

from paradex.utils.file_io import find_latest_directory, shared_dir, home_path, load_yaml, load_latest_C2R, get_robot_urdf_path, rsc_path
from paradex.robot.curobo import CuroboPlanner
from paradex.visualization.visualizer.viser import ViserViewer
from paradex.inference.util import get_linear_path
from paradex.robot.robot_wrapper import RobotWrapper
from paradex.robot.mimic_joint import parse_inspire

xarm_init_pose = np.array([-0.8048279285430908, 0.2773207128047943, -1.4464116096496582, 2.0092501640319824, 0.7059974074363708, -2.361839532852173]) # Initial xarm pose for every grasp 

Z_OFFSET = np.array([0.0, 0.0, 0.12])
Z_NUM = 2

X_OFFSET = np.array([0.13, 0.0, 0.0])
X_NUM = 2

Y_OFFSET = np.array([0.0, 0.13, 0.0])
Y_NUM = 5

LINEAR_START = 0.8
LINEAR_DIRECTION = np.array([0.0, -1.0, 0.0])
# [[ 0.04099059 -0.99915576 -0.00274577]
#  [-0.99902283 -0.04103029  0.01642854]
#  [-0.01652733  0.00206967 -0.99986127]]

demo_data = os.path.join(shared_dir, "object_6d", "demo_data")
C2R = load_latest_C2R()

# PICK_ORDER = ['brown_1', 'red_12', 'red_13', 'red_16', 'yellow_6', 'red_18', 'yellow_10', 'red_19', 'yellow_9', 'yellow_11', 'brown_4', 'yellow_8', 'brown_2', 'red_15', 'brown_3', 'yellow_5', 'red_14']
PICK_ORDER = ['brown_1', 'red_12', 'red_13', 'red_14', 'brown_0', 'yellow_6', 'red_16', 'yellow_5', 'yellow_8', 'yellow_9', 'red_18', 'yellow_10', 'yellow_11', 'brown_2', 'yellow_7', 'red_19', 'brown_3', "red_15", "red_17", "brown_4"]

OBSTACLE = {'cuboid': 
                { # xyz, quaternion
                 'table': {'dims': [2, 2, 0.2], 'pose': [0,0,-0.12,0,0,0,1]}, 
                 # 'baseback': {'dims': [2.0, 0.5, 2.0], 'pose': [-1.0857807924568896, -0.011288158965621076, -0.015956839973832793, 0.7082079218969054, -0.00040869377511796283, -0.006448498134229638, 0.7059743544943244]}, 
                 'basetop': {'dims': [5.0, 5.0, 0.2], 'pose': [0, 0, 1.0, 0, 0, 0, 1]}, 
                 'shelf0': {'dims': [0.8, 0.33, 2.02], 'pose': [-0.68+0.33/2, -0.6+0.8/2, -0.76, 0.70710678, 0, 0, 0.70710678]}, 
                 'shelf1': {'dims': [0.8, 0.03, 2.06], 'pose': [-0.68+0.03/2+0.33, -0.6+0.8/2, -0.75, 0.70710678, 0, 0, 0.70710678]}, # + 0.1
                 'shelf2': {'dims': [0.8, 0.1, 1.0], 'pose': [-0.68-0.1/2, -0.6+0.8/2, 0.2541, 0.70710678, 0, 0, 0.70710678]},  # + 1.0141
                 'shelf3': {'dims': [0.8, 0.33, 0.05], 'pose': [-0.68+0.33/2, -0.6+0.8/2, 0.574, 0.70710678, 0, 0, 0.70710678]},  #+ 1.334
                 # 'table': {'dims': [5.0, 5.0, 5.0], 'pose': [-0.07808975157119691, -0.5062144110803565, -2.584682669305668, 0.6999402146008835, 0.004682160214565101, -0.0007793753508808123, -0.7141856662901159]}}
                 }
            }

# TODO:
# [X] make floor
# [X] add object to OBSTACLE
# [X] change linear path planning to planning
# [] make order of pick

# We use object coordinate as it's center is in the bottom, middle of the object, with z-axis pointing up
# However center of ramen mesh is not as it is so we need to adjust it
ramen_offset = {
    "brown":np.array([[1, 0, 0, 0], 
                      [0, 0, 1, -0.055], 
                      [0, -1, 0, 0], 
                      [0, 0, 0, 1]]),
    "red":np.array([[1, 0, 0, 0], 
                      [0, 0, 1, -0.055], 
                      [0, -1, 0, 0], 
                      [0, 0, 0, 1]]),
    "yellow":np.array([[1, 0, 0, 0], 
                      [0, 0, 1, -0.055], 
                      [0, -1, 0, 0], 
                      [0, 0, 0, 1]])
}

def load_pick_position():
    obj_6d_path = os.path.join(shared_dir, 'object_6d', 'data', 'obj_output')
    latest_dir = find_latest_directory(obj_6d_path)
    obj_T = {}

    with open(os.path.join(obj_6d_path, latest_dir, 'obj_T.pkl'), 'rb') as f:
        obj_output = pickle.load(f)
    
    obj_idx = 0
    for obj_type, obj_list in obj_output.items():
        obj_type = obj_type.split('_')[0]  # brown_ramen_1 -> brown
        for obj_name, obj_se3 in obj_list.items():
            obj_se3 = np.linalg.inv(C2R) @ obj_se3 @ ramen_offset[obj_type]

            obj_T[f"{obj_type}_{obj_idx}"] = obj_se3
            obj_idx += 1

    return obj_T

# shared_data/object_6d/demo_data/myrobot
def load_pick_traj():
    demo_path = os.path.join(demo_data, "ramen")
    demo_dict = {}
    for idx in os.listdir(demo_path):
        wristSe3 = np.load(os.path.join(demo_path, idx, "grasp", "obj_wristSe3.npy"))
        hand_traj = np.load(os.path.join(demo_path, idx, "grasp", "inspire", "position.npy"))
        demo_dict[idx] = (wristSe3, hand_traj)
    return demo_dict


NUM_GRASP = 60
def load_pick_pose(pick_pose, grasp_se3):
    theta_list = np.linspace(0, np.pi*2, NUM_GRASP)
    rot_list = [np.eye(4) for _ in range(NUM_GRASP)]
    for i, theta in enumerate(theta_list):
        rot_list[i][:3,:3] = R.from_euler('z', theta).as_matrix()

    grasp_pose_dict = {}
    for obj_name, obj_se3 in pick_pose.items():
        grasp_pose_dict[obj_name] = np.array([obj_se3 @ rot @ grasp_se3 for rot in rot_list])

    return grasp_pose_dict

obj_dict = {}
def load_planner(pick_position):
    for obj_name, obj_se3 in pick_position.items():
        obj_type = obj_name.split('_')[0]
        mesh_path = os.path.join(rsc_path, "object", obj_type+"_ramen_von", obj_type+"_ramen_von.obj")
        obj_dict[obj_name] = {'pose':obj_se3, 'file_path':mesh_path}

    robot_cfg = load_yaml(os.path.join(demo_data, "myrobot/xarm_inspire.yml"))["robot_cfg"]
    tensor_args = TensorDeviceType()
    return CuroboPlanner(OBSTACLE, obj_dict, robot_cfg, tensor_args)


def load_visualizer(pick_position):
    visualizer = ViserViewer(up_direction=np.array([0,0,1]))

    visualizer.add_floor()
    visualizer.add_robot("xarm", get_robot_urdf_path(arm_name="xarm", hand_name="inspire"))

    mesh_dict = {}
    for color in ["brown", "red", "yellow"]:
        mesh_path = os.path.join(rsc_path, "object", f"{color}_ramen_von", f"{color}_ramen_von.obj")
        mesh = trimesh.load(mesh_path)
        mesh_dict[color] = mesh

    for obj_name, obj_pose in pick_position.items():
        visualizer.add_object(obj_name, mesh_dict[obj_name.split('_')[0]], obj_pose)
    
    # make trimesh objects
    for obj_type, obstacles in OBSTACLE.items():
        if obj_type == 'cuboid':
            for obs_name, obs_data in obstacles.items():
                dims = obs_data['dims']
                pose = obs_data['pose']
                
                # Create box mesh
                box = trimesh.creation.box(extents=dims)
                
                # Create transformation matrix
                obs_T = np.eye(4)
                obs_T[:3, 3] = pose[:3]
                wxyz = [pose[6], pose[3], pose[4], pose[5]]  # Convert to wxyz format
                obs_T[:3, :3] = R.from_quat(wxyz).as_matrix()
                # 그냥 add_object 호출!
                visualizer.add_object(f"obstacle_{obs_name}", box, obs_T)

    return visualizer

def get_pick_traj(init_qpos, pick_position, grasp_se3):
    grasp_pose_dict = load_pick_pose(pick_position, grasp_se3)
    goal_pose = np.concatenate([grasp_pose_dict[obj_name] for obj_name in pick_position.keys()], axis=0)

    goal_idx, qpos_traj = planner.plan_goalset(init_qpos, goal_pose) # goal_pose NX4X4
    obj_name = list(pick_position.keys())[goal_idx // NUM_GRASP]
    return obj_name, qpos_traj

def get_pick_obj_traj(init_qpos, obj_se3, grasp_se3):
    pick_position = {"tmp":obj_se3}
    goal_pose = load_pick_pose(pick_position, grasp_se3)["tmp"]
    goal_idx, qpos_traj = planner.plan_goalset(init_qpos, goal_pose) # goal_pose NX4X4

    return qpos_traj

def merge_qpos(xarm, inspire_qpos):
    if len(xarm.shape) == 1:
        xarm = np.repeat(xarm[None, :], repeats=inspire_qpos.shape[0], axis=0)
    if len(inspire_qpos.shape) == 1:
        inspire_qpos = np.repeat(inspire_qpos[None, :], repeats=xarm.shape[0], axis=0)
    return np.concatenate([xarm, inspire_qpos], axis=1)


robot = RobotWrapper(get_robot_urdf_path(arm_name="xarm", hand_name=None))
def linear_trajectory(init_qpos, target_se3, length=50):

    robot.compute_forward_kinematics(init_qpos)
    init_xarm_se3 = robot.get_link_pose(robot.get_link_index("link6"))
    
    xarm_se3_traj, _ = get_linear_path(init_xarm_se3, target_se3, np.zeros(6), np.zeros(6), length=length)
    xarm_qpos_traj = [init_qpos]
    for xarm_se3 in xarm_se3_traj:
        qpos, succ = robot.solve_ik(xarm_se3, "link6", xarm_qpos_traj[-1])
        if not succ:
            qpos = xarm_qpos_traj[-1]
        xarm_qpos_traj.append(qpos)
    return np.array(xarm_qpos_traj)[1:]

def get_lift_traj(init_qpos, height, length=50, linear=True):
    robot.compute_forward_kinematics(init_qpos)
    init_xarm_se3 = robot.get_link_pose(robot.get_link_index("link6"))
    target_se3 = init_xarm_se3.copy()
    target_se3[2, 3] += height
    if linear:
        xarm_qpos_traj = linear_trajectory(init_qpos, target_se3, length=length)
    else:
        goal_idx, xarm_qpos_traj = planner.plan_goalset(init_qpos, target_se3[np.newaxis, :])
    return xarm_qpos_traj

def get_obj_traj(qpos_traj, grasp_se3):
    obj_pose = []
    for qpos in qpos_traj:
        robot.compute_forward_kinematics(qpos)
        xarm_se3 = robot.get_link_pose(robot.get_link_index("link6"))
        obj_se3 = xarm_se3 @ np.linalg.inv(grasp_se3)
        obj_pose.append(obj_se3)

    return obj_pose

# def get_move_traj(init_qpos, target_se3, length=50):
#     desired_j1_degree = np.pi / 2
#     cur_j1_degree = init_qpos[0]

#     num_step = int(abs(desired_j1_degree - cur_j1_degree) / np.pi * 180) + 1
#     num_step = max(num_step, 1)
#     xarm_qpos_traj_pre = []
#     for i in range(num_step):
#         ratio = (i+1) / num_step
#         j1 = cur_j1_degree * (1-ratio) + desired_j1_degree * ratio
#         qpos = init_qpos.copy()
#         qpos[0] = j1
#         xarm_qpos_traj_pre.append(qpos)
    
#     xarm_qpos_traj = linear_trajectory(xarm_qpos_traj_pre[-1], target_se3, length=length)
#     xarm_qpos_traj = np.concatenate([np.array(xarm_qpos_traj_pre), xarm_qpos_traj], axis=0)
    
#     return xarm_qpos_traj

def get_move_traj(init_qpos, target_qpos, length=50):
    qpos_traj = []
    for i in range(length):
        ratio = (i+1) / length
        qpos = init_qpos * (1-ratio) + target_qpos * ratio
        qpos_traj.append(qpos)
    qpos_traj = np.array(qpos_traj)
    return qpos_traj

pick_position = load_pick_position()
offset = 0
for i in range(len(PICK_ORDER)):
    if os.path.exists(os.path.join("data", "pick_traj", f"{i}.npy")):
        obj_name = PICK_ORDER[i]
        pick_position.pop(obj_name)
        offset += 1
        print(offset, obj_name)
grasp_policy_dict = load_pick_traj()

grasp_idx = "7"
inspire_traj = parse_inspire(grasp_policy_dict[grasp_idx][1], joint_order = ['right_thumb_1_joint', 'right_thumb_2_joint', 'right_index_1_joint', 'right_middle_1_joint', 'right_ring_1_joint', 'right_little_1_joint', ])[::9]
orig_inspire_traj = grasp_policy_dict[grasp_idx][1].copy()

# start from zero state
inspire_traj_pre = []
for i in range(15):
    inspire_traj_pre.append(inspire_traj[0] * i / 15)
inspire_traj = np.concatenate([np.array(inspire_traj_pre), inspire_traj], axis=0)
grasp_se3 = grasp_policy_dict[grasp_idx][0]

orig_inspire_traj_pre = []
for i in range(15):
    orig_inspire_traj_pre.append(orig_inspire_traj[0] * i / 15 + np.array([1000, 1000, 1000, 1000, 1000 ,1000]) * (1 - i / 15))
orig_inspire_traj = np.concatenate([np.array(orig_inspire_traj_pre), orig_inspire_traj], axis=0)

print("initializing planner")
planner = load_planner(pick_position)
print("planner initialized")

visualizer = load_visualizer(pick_position)

# robot_mesh = planner.get_robot_mesh(xarm_init_pose)
planner.world_cfg.save_world_as_mesh(os.path.join(demo_data, "obstacle_mesh.obj"))

# robot_scene = trimesh.Scene()
# for obj in robot_mesh:
#     robot_scene.add_geometry(obj)
# robot_scene.export("data/robot_mesh.obj")
print(offset)
for step in range(offset, len(pick_position)+offset):
    os.makedirs(os.path.join(demo_data, "obstacle"), exist_ok=True)
    planner.world_cfg.save_world_as_mesh(os.path.join(demo_data, f"obstacle", f"{step}.obj"))

    # approach
    pick_tot_traj = []
    
    if step < len(PICK_ORDER):
        if os.path.exists(os.path.join("data", "pick_traj", f"{step}.npy")):
            obj_dict.pop(PICK_ORDER[step])
            pick_position.pop(PICK_ORDER[step])
            planner.update_world(obj_dict)
            pick_traj = np.load(os.path.join("data", "pick_traj", f"{step}.npy"))
            visualizer.add_traj(f"pick_{PICK_ORDER[step]}", {"xarm":pick_traj})
            continue
        obj_name = PICK_ORDER[step]
        pick_xarm_traj = get_pick_obj_traj(xarm_init_pose, pick_position[obj_name], grasp_se3)
    else:
        obj_name, pick_xarm_traj = get_pick_traj(xarm_init_pose, pick_position, grasp_se3)
    pick_traj = merge_qpos(pick_xarm_traj[:,:6], inspire_traj[0])
    visualizer.add_traj(f"pick_{obj_name}", {"xarm":pick_traj})
    pick_tot_traj.append(merge_qpos(pick_xarm_traj[:,:6], orig_inspire_traj[0]))
    os.makedirs(os.path.join("data", "tmp_pick_traj"), exist_ok=True)
    np.save(os.path.join("data", "tmp_pick_traj", f"{step}_{obj_name}.npy"), np.concatenate(pick_tot_traj, axis=0))
    # grasp
    grasp_traj = merge_qpos(pick_xarm_traj[-1], inspire_traj)
    pick_tot_traj.append(merge_qpos(pick_xarm_traj[-1], orig_inspire_traj))
    # visualizer.add_traj(f"grasp_{obj_name}", {"xarm":grasp_traj})

    # Delete lifted object from mesh DB    
    obj_dict.pop(obj_name)
    pick_position.pop(obj_name)
    planner.update_world(obj_dict)
    planner.motion_gen.world_model.save_world_as_mesh(os.path.join(demo_data, f"obstacle_mesh_{step}.obj"))

    lift_xarm_traj = get_lift_traj(pick_xarm_traj[-1], height=0.2, length=50, linear=False)
    lift_obj_pose = get_obj_traj(lift_xarm_traj[:, :6], grasp_se3)

    lift_traj = merge_qpos(lift_xarm_traj, np.repeat(inspire_traj[-1][None, :], repeats=lift_xarm_traj.shape[0], axis=0))
    visualizer.add_traj(f"lift_{obj_name}", {"xarm":lift_traj}, {obj_name:np.array(lift_obj_pose)})
    pick_tot_traj.append(merge_qpos(lift_xarm_traj, orig_inspire_traj[-1]))

    # move to initial of put trajectory
    release_traj = np.load(os.path.join(demo_data, "place_traj", f"{step}.npy"))
    robot.compute_forward_kinematics(release_traj[0, :6])
    put_xarm_init_se3 = robot.get_link_pose(robot.get_link_index("link6"))

    move_xarm_traj = get_move_traj(lift_xarm_traj[-1], release_traj[0, :6])# linear_trajectory(lift_xarm_traj[-1], put_xarm_init_se3, length=50)
    move_traj = merge_qpos(move_xarm_traj, np.repeat(inspire_traj[-1][None, :], repeats=move_xarm_traj.shape[0], axis=0))

    move_obj_pose = get_obj_traj(move_xarm_traj, grasp_se3)
    visualizer.add_traj(f"move_{obj_name}", {"xarm":move_traj}, {obj_name:np.array(move_obj_pose)})
    pick_tot_traj.append(merge_qpos(move_xarm_traj, orig_inspire_traj[-1]))
    # put 
    visualizer.add_traj(f"put_{obj_name}", {"xarm":release_traj})#, {obj_name:np.array(get_obj_traj(put_xarm_traj, grasp_se3))})

    os.makedirs(os.path.join("data", "pick_traj"), exist_ok=True)
    np.save(os.path.join("data", "pick_traj", f"{step}.npy"), np.concatenate(pick_tot_traj, axis=0))
    print(f"Save pick traj {step}, {obj_name}, length: {np.concatenate(pick_tot_traj, axis=0).shape[0]}")

visualizer.start_viewer()